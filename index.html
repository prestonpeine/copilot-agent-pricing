<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Copilot Agent Pricing Model â€” Break-Even Analysis</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.7/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-annotation@3.1.0/dist/chartjs-plugin-annotation.min.js"></script>
<style>
/* â”€â”€â”€ Reset & Variables â”€â”€â”€ */
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #f4f6f9;
  --surface: #ffffff;
  --text: #1e293b;
  --text-muted: #64748b;
  --border: #e2e8f0;
  --accent: #6366f1;
  --accent-light: #818cf8;
  --header-bg: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
  --green: #10b981;
  --red: #ef4444;
  --orange: #f59e0b;
  --shadow-sm: 0 1px 3px rgba(0,0,0,.08);
  --shadow-md: 0 4px 12px rgba(0,0,0,.1);
  --shadow-lg: 0 8px 30px rgba(0,0,0,.12);
  --radius: 12px;
  --radius-sm: 8px;

  /* User group colors */
  --flw: #3b82f6;
  --iw: #10b981;
  --mgr: #f59e0b;
  --exec: #8b5cf6;
}

html { font-size: 15px; scroll-behavior: smooth; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Inter, Roboto, sans-serif;
  background: var(--bg);
  color: var(--text);
  line-height: 1.5;
  min-height: 100vh;
}

/* â”€â”€â”€ Header â”€â”€â”€ */
.hero {
  background: var(--header-bg);
  color: #fff;
  padding: 2.5rem 2rem 2rem;
  text-align: center;
}
.hero h1 { font-size: 1.8rem; font-weight: 700; letter-spacing: -.02em; margin-bottom: .25rem; }
.hero p { color: #94a3b8; font-size: .95rem; max-width: 600px; margin: 0 auto .6rem; }
.hero .formula {
  display: inline-block;
  background: rgba(99,102,241,.2);
  border: 1px solid rgba(99,102,241,.35);
  border-radius: 8px;
  padding: .45rem 1.2rem;
  font-family: 'Courier New', monospace;
  font-size: .85rem;
  color: #c7d2fe;
  margin-top: .5rem;
}

/* â”€â”€â”€ PUPM Control (sticky in header) â”€â”€â”€ */
.pupm-bar {
  background: #1e293b;
  border-top: 1px solid rgba(255,255,255,.06);
  padding: 1rem 2rem;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 1.2rem;
  flex-wrap: wrap;
  position: sticky;
  top: 0;
  z-index: 100;
  box-shadow: 0 4px 20px rgba(0,0,0,.3);
}
.pupm-bar label {
  color: #cbd5e1;
  font-size: .85rem;
  font-weight: 500;
}
.pupm-bar .pupm-value {
  background: var(--accent);
  color: #fff;
  font-weight: 700;
  font-size: 1.1rem;
  padding: .2rem .7rem;
  border-radius: 6px;
  min-width: 60px;
  text-align: center;
}

/* â”€â”€â”€ Layout â”€â”€â”€ */
.container { max-width: 1340px; margin: 0 auto; padding: 1.5rem; }
.section-title {
  font-size: 1.15rem;
  font-weight: 700;
  margin-bottom: 1rem;
  display: flex;
  align-items: center;
  gap: .5rem;
}
.section-title .icon {
  width: 28px; height: 28px;
  border-radius: 6px;
  display: flex; align-items: center; justify-content: center;
  font-size: .85rem;
  color: #fff;
}

/* â”€â”€â”€ Cards â”€â”€â”€ */
.card {
  background: var(--surface);
  border-radius: var(--radius);
  border: 1px solid var(--border);
  box-shadow: var(--shadow-sm);
  overflow: visible;
  transition: box-shadow .2s;
}
.card:hover { box-shadow: var(--shadow-md); }

.card-header {
  padding: .8rem 1.2rem;
  font-weight: 600;
  font-size: .9rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
  cursor: pointer;
  user-select: none;
}
.card-header .chevron { transition: transform .2s; font-size: .7rem; }
.card-header.collapsed .chevron { transform: rotate(-90deg); }
.card-body { padding: .6rem 1.2rem 1.2rem; }

/* â”€â”€â”€ Agent Config Grid â”€â”€â”€ */
.agent-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(290px, 1fr)); gap: 1rem; }
.agent-card { border-left: 4px solid var(--accent); }
.agent-card .agent-name { font-weight: 600; font-size: .85rem; margin-bottom: .6rem; }
.agent-card .agent-cost-per-session {
  font-size: .75rem;
  color: var(--text-muted);
  margin-top: .5rem;
  text-align: right;
  font-weight: 500;
}
.agent-card .agent-cost-per-session strong {
  color: var(--accent);
  font-size: .9rem;
}

/* â”€â”€â”€ User Group Cards â”€â”€â”€ */
.user-grid { display: flex; flex-direction: column; gap: 1rem; margin-top: .5rem; }

.user-card { position: relative; overflow: visible; }
.user-card .card-accent {
  height: 4px;
  border-radius: var(--radius) var(--radius) 0 0;
}
.user-card .user-header {
  padding: .9rem 1.2rem .5rem;
  display: flex;
  align-items: flex-start;
  justify-content: space-between;
  gap: .5rem;
  flex-wrap: wrap;
}
.user-card .user-header .group-name {
  font-weight: 700;
  font-size: .95rem;
  display: flex;
  align-items: center;
  gap: .4rem;
}
.user-card .user-header .group-name .dot {
  width: 10px; height: 10px;
  border-radius: 50%;
  display: inline-block;
}
.user-card .user-header .monthly-cost {
  font-size: 1.1rem;
  font-weight: 700;
  white-space: nowrap;
}
.user-card .card-body { padding: .4rem 1.2rem 1rem; }

.cost-badge {
  display: inline-flex;
  align-items: center;
  gap: .3rem;
  font-size: .7rem;
  font-weight: 600;
  padding: .15rem .5rem;
  border-radius: 20px;
  white-space: nowrap;
}
.cost-badge.under { background: rgba(16,185,129,.12); color: var(--green); }
.cost-badge.over  { background: rgba(239,68,68,.12); color: var(--red); }
.cost-badge.even  { background: rgba(245,158,11,.12); color: var(--orange); }

/* â”€â”€â”€ Slider styling â”€â”€â”€ */
.slider-row {
  display: flex;
  align-items: center;
  gap: .6rem;
  margin-bottom: .55rem;
}
.slider-row label {
  font-size: .78rem;
  color: var(--text-muted);
  min-width: 95px;
  flex-shrink: 0;
  white-space: nowrap;
}
.slider-row input[type="range"] { flex: 1; height: 6px; min-width: 0; }
.slider-row .slider-val {
  font-size: .78rem;
  font-weight: 600;
  min-width: 55px;
  text-align: right;
  color: var(--text);
  flex-shrink: 0;
  white-space: nowrap;
}

input[type="range"] {
  -webkit-appearance: none;
  appearance: none;
  background: var(--border);
  border-radius: 4px;
  outline: none;
  cursor: pointer;
}
input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 16px; height: 16px;
  border-radius: 50%;
  background: var(--accent);
  border: 2px solid #fff;
  box-shadow: 0 1px 4px rgba(0,0,0,.2);
  cursor: pointer;
}
input[type="range"]::-moz-range-thumb {
  width: 16px; height: 16px;
  border-radius: 50%;
  background: var(--accent);
  border: 2px solid #fff;
  box-shadow: 0 1px 4px rgba(0,0,0,.2);
  cursor: pointer;
}

/* Composition sub-section */
.comp-label {
  font-size: .75rem;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: .04em;
  margin: .7rem 0 .35rem;
  border-top: 1px solid var(--border);
  padding-top: .6rem;
}
.comp-bar {
  display: flex;
  height: 8px;
  border-radius: 4px;
  overflow: hidden;
  margin-bottom: .5rem;
}
.comp-bar div { transition: width .2s; }

/* â”€â”€â”€ Chart Section â”€â”€â”€ */
.chart-section {
  margin-top: 0;
}
.chart-wrap {
  background: var(--surface);
  border-radius: var(--radius);
  border: 1px solid var(--border);
  box-shadow: var(--shadow-sm);
  padding: 1.5rem;
  position: relative;
}
.chart-wrap canvas { max-height: none; }
.chart-legend {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: .5rem 1.4rem;
  padding: .6rem 0;
}
.chart-legend-item {
  display: inline-flex;
  align-items: center;
  gap: .4rem;
  font-size: .82rem;
  color: var(--text);
  cursor: default;
}
.chart-legend-item .legend-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  flex-shrink: 0;
}
.chart-legend-item .legend-be {
  font-weight: 600;
}

/* â”€â”€â”€ Org Summary â”€â”€â”€ */
.org-summary {
  margin-top: 2rem;
  margin-bottom: 3rem;
}
.summary-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 1rem;
  margin-bottom: 1.2rem;
}
.summary-stat {
  background: var(--surface);
  border-radius: var(--radius-sm);
  border: 1px solid var(--border);
  padding: 1rem 1.2rem;
  text-align: center;
}
.summary-stat .stat-label { font-size: .75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: .04em; font-weight: 600; }
.summary-stat .stat-value { font-size: 1.5rem; font-weight: 800; margin-top: .25rem; }
.summary-stat .stat-sub { font-size: .75rem; color: var(--text-muted); margin-top: .15rem; }

.summary-table {
  width: 100%;
  border-collapse: separate;
  border-spacing: 0;
  background: var(--surface);
  border-radius: var(--radius);
  border: 1px solid var(--border);
  overflow: hidden;
  box-shadow: var(--shadow-sm);
}
.summary-table th, .summary-table td {
  padding: .65rem 1rem;
  text-align: right;
  font-size: .82rem;
}
.summary-table th {
  background: #f8fafc;
  font-weight: 600;
  color: var(--text-muted);
  font-size: .72rem;
  text-transform: uppercase;
  letter-spacing: .04em;
  border-bottom: 1px solid var(--border);
}
.summary-table td { border-bottom: 1px solid var(--border); }
.summary-table tr:last-child td { border-bottom: none; }
.summary-table td:first-child, .summary-table th:first-child { text-align: left; font-weight: 600; }
.summary-table .total-row { background: #f8fafc; font-weight: 700; }
.summary-table .total-row td { border-top: 2px solid var(--border); }

/* Summary table user-count input */
.user-count-input {
  width: 80px;
  padding: .25rem .4rem;
  border: 1px solid var(--border);
  border-radius: 4px;
  font-size: .82rem;
  font-weight: 700;
  text-align: right;
  font-family: inherit;
  color: var(--text);
  outline: none;
  transition: border-color .2s;
}
.user-count-input:focus {
  border-color: var(--accent);
  box-shadow: 0 0 0 2px rgba(99,102,241,.15);
}

.recommendation {
  margin-top: 1.2rem;
  padding: 1rem 1.4rem;
  border-radius: var(--radius-sm);
  font-size: .9rem;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: .6rem;
}
.recommendation.consumption-wins { background: rgba(16,185,129,.1); color: #065f46; border: 1px solid rgba(16,185,129,.3); }
.recommendation.license-wins    { background: rgba(99,102,241,.1); color: #3730a3; border: 1px solid rgba(99,102,241,.3); }
.recommendation .rec-icon { font-size: 1.6rem; }
.recommendation .rec-savings { font-size: 1.1rem; font-weight: 800; }
.rec-annual {
  display: inline-flex;
  align-items: center;
  gap: .5rem;
  margin-top: .5rem;
  padding: .5rem 1rem;
  border-radius: 8px;
  font-size: 1.3rem;
  font-weight: 800;
  letter-spacing: -.01em;
}
.rec-annual .annual-label {
  font-size: .8rem;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: .05em;
  opacity: .7;
}
.consumption-wins .rec-annual { background: rgba(16,185,129,.15); color: #065f46; }
.license-wins .rec-annual { background: rgba(99,102,241,.15); color: #3730a3; }

/* â”€â”€â”€ Responsive â”€â”€â”€ */
@media (max-width: 768px) {
  .hero h1 { font-size: 1.4rem; }
  .container { padding: 1rem; }
  .agent-grid { grid-template-columns: 1fr; }
  .summary-grid { grid-template-columns: 1fr 1fr; }
}

/* â”€â”€â”€ Utility â”€â”€â”€ */
.mt-1 { margin-top: 1rem; }
.mb-1 { margin-bottom: 1rem; }
.text-center { text-align: center; }
.hidden { display: none; }

/* â”€â”€â”€ Section Divider â”€â”€â”€ */
.section-divider {
  border: none;
  border-top: 1px solid var(--border);
  margin: 2rem 0 1.5rem;
}

/* â”€â”€â”€ Formula Tooltip â”€â”€â”€ */
.formula-wrap {
  position: relative;
  display: inline-block;
  cursor: help;
}
.formula-tooltip {
  display: none;
  position: absolute;
  top: calc(100% + 12px);
  left: 50%;
  transform: translateX(-50%);
  background: #fff;
  color: var(--text);
  border-radius: var(--radius-sm);
  box-shadow: var(--shadow-lg);
  padding: 1rem 1.2rem;
  width: 420px;
  z-index: 200;
  text-align: left;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Inter, Roboto, sans-serif;
  font-size: .82rem;
  line-height: 1.6;
}
.formula-tooltip::before {
  content: '';
  position: absolute;
  top: -6px;
  left: 50%;
  transform: translateX(-50%) rotate(45deg);
  width: 12px;
  height: 12px;
  background: #fff;
}
.formula-wrap:hover .formula-tooltip { display: block; }
.formula-tooltip .def-term { font-weight: 700; color: var(--accent); }
.formula-tooltip .def-row { margin-bottom: .4rem; }
.formula-tooltip .def-row:last-child { margin-bottom: 0; }
.formula-wrap .formula { border-bottom: 1px dashed rgba(199,210,254,.4); }

/* â”€â”€â”€ Reset Button â”€â”€â”€ */
.reset-btn {
  background: transparent;
  border: 1px solid rgba(255,255,255,.2);
  color: #94a3b8;
  font-size: .78rem;
  font-weight: 500;
  padding: .35rem .9rem;
  border-radius: 6px;
  cursor: pointer;
  transition: all .2s;
}
.reset-btn:hover {
  background: rgba(255,255,255,.1);
  color: #e2e8f0;
  border-color: rgba(255,255,255,.35);
}

/* â”€â”€â”€ Accordion â”€â”€â”€ */
.accordion-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  cursor: pointer;
  user-select: none;
  padding: .2rem 0;
}
.accordion-header .section-title { margin-bottom: 0; pointer-events: none; }
.accordion-chevron {
  font-size: 1.4rem;
  color: var(--accent);
  transition: transform .25s, background .2s;
  padding: .3rem .55rem;
  line-height: 1;
  background: rgba(99,102,241,.1);
  border-radius: 6px;
  border: 1px solid rgba(99,102,241,.2);
}
.accordion-chevron:hover { background: rgba(99,102,241,.2); color: var(--accent); }
.accordion-chevron.collapsed { transform: rotate(-90deg); }

/* Agent summary bar (visible when accordion collapsed) */
.agent-summary-bar {
  display: flex;
  flex-wrap: wrap;
  gap: .5rem;
  padding: .5rem 0 .8rem;
}
.agent-summary-chip {
  display: inline-flex;
  align-items: center;
  gap: .35rem;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: .35rem .75rem;
  font-size: .78rem;
  box-shadow: var(--shadow-sm);
}
.agent-summary-chip .dot {
  width: 8px; height: 8px;
  border-radius: 50%;
  display: inline-block;
}
.agent-summary-chip .chip-cost {
  font-weight: 700;
  color: var(--accent);
}

/* â”€â”€â”€ Main Two-Column Layout â”€â”€â”€ */
.main-layout {
  display: grid;
  grid-template-columns: minmax(320px, 1fr) minmax(380px, 1.3fr);
  gap: 1.5rem;
  align-items: start;
}
.right-col {
  position: sticky;
  top: 70px;
}

/* â”€â”€â”€ User card accordion â”€â”€â”€ */
.user-toggle {
  cursor: pointer;
  user-select: none;
}
.toggle-chevron {
  font-size: 1.3rem;
  color: var(--accent);
  transition: transform .25s, background .2s;
  flex-shrink: 0;
  line-height: 1;
  background: rgba(99,102,241,.1);
  border-radius: 6px;
  border: 1px solid rgba(99,102,241,.2);
  padding: .25rem .45rem;
}
.toggle-chevron:hover { background: rgba(99,102,241,.2); color: var(--accent); }
.toggle-chevron.collapsed {
  transform: rotate(-90deg);
  animation: pulse-hint 2s ease-in-out 3;
}
@keyframes pulse-hint {
  0%, 100% { background: rgba(99,102,241,.1); }
  50% { background: rgba(99,102,241,.25); box-shadow: 0 0 0 3px rgba(99,102,241,.1); }
}
.card-body.collapsed {
  display: none;
}

@media (max-width: 900px) {
  .main-layout {
    grid-template-columns: 1fr;
  }
  .right-col {
    position: static;
  }
}
</style>
</head>
<body>

<!-- â•â•â• HERO â•â•â• -->
<div class="hero">
  <h1>Copilot Agent Pricing Model</h1>
  <p>Compare consumption-based pricing vs per-user license to find your break-even point</p>
  <div class="formula-wrap">
    <div class="formula">Total Cost = Cadence Ã— Conversation Ã— Computation Ã— Composition</div>
    <div class="formula-tooltip">
      <div class="def-row"><span class="def-term">Cadence:</span> How many agent sessions per month?</div>
      <div class="def-row"><span class="def-term">Conversation:</span> Human-to-agent interaction â€” how many back-and-forth turns per session?</div>
      <div class="def-row"><span class="def-term">Computation:</span> Agent-to-back office interaction â€” the cost of the "brainpower," which increases as fan-out of data and tool calls grows per turn.</div>
      <div class="def-row"><span class="def-term">Composition:</span> The mixture of different agent types used during the month.</div>
    </div>
  </div>
</div>

<!-- â•â•â• PUPM BAR â•â•â• -->
<div class="pupm-bar">
  <label>Per-User / Month License (PUPM):</label>
  <input type="range" id="pupmSlider" min="1" max="30" step="1" value="30" style="width:240px;">
  <div class="pupm-value" id="pupmValue">$30</div>
  <button class="reset-btn" id="resetBtn">â†º Reset Defaults</button>
</div>

<div class="container">

  <!-- â•â•â• AGENT CONFIGURATION (Accordion) â•â•â• -->
  <div class="mt-1" id="agentSection">
    <div class="accordion-header" id="agentToggle" title="Expand to edit">
      <div class="section-title">
        <span class="icon" style="background:var(--accent);">âš™</span>
        Agent Configuration
      </div>
      <span class="accordion-chevron collapsed" id="agentChevron">â–¾</span>
    </div>
    <div class="agent-summary-bar" id="agentSummaryBar"></div>
    <div id="agentBody" style="display:none;">
      <div class="agent-grid" id="agentGrid"></div>
    </div>
  </div>

  <hr class="section-divider">

  <!-- â•â•â• TWO-COLUMN LAYOUT: User Groups + Break-Even â•â•â• -->
  <div class="main-layout">
    <div class="left-col">
      <div class="section-title">
        <span class="icon" style="background:#334155;">ğŸ‘¥</span>
        User Groups
      </div>
      <div class="user-grid" id="userGrid"></div>
    </div>
    <div class="right-col">
      <div class="chart-section">
        <div class="section-title">
          <span class="icon" style="background:#0f172a;">ğŸ“Š</span>
          Break-Even Analysis
        </div>
        <div class="chart-legend" id="chartLegend"></div>
        <div class="chart-wrap">
          <canvas id="breakEvenChart"></canvas>
        </div>
      </div>
    </div>
  </div>

  <hr class="section-divider">

  <!-- â•â•â• ORG SUMMARY â•â•â• -->
  <div class="org-summary">
    <div class="section-title">
      <span class="icon" style="background:#1e293b;">ğŸ¢</span>
      Organization Cost Summary
    </div>
    <div class="summary-grid" id="summaryStats"></div>
    <table class="summary-table" id="summaryTable">
      <thead></thead>
      <tbody></tbody>
    </table>
    <div id="recommendation"></div>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DATA MODEL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const STORAGE_KEY = 'copilot-agent-pricing-v6';

const DEFAULT_AGENTS = [
  { id: 'info',     name: 'Information Retrieval', turns: 3,  costPerTurn: 0.12, color: '#3b82f6' },
  { id: 'task',     name: 'Task Agent',            turns: 6,  costPerTurn: 0.12, color: '#10b981' },
  { id: 'analyst',  name: 'Analyst Agent',         turns: 10, costPerTurn: 0.20, color: '#f59e0b' },
  { id: 'strategy', name: 'Strategy Agent',        turns: 16, costPerTurn: 0.30, color: '#8b5cf6' },
];

const DEFAULT_GROUPS = [
  {
    id: 'flw', name: 'Frontline Worker', abbrev: 'FLW', color: '#3b82f6',
    cadence: 25, userCount: 1,
    composition: { info: 50, task: 35, analyst: 12, strategy: 3 }
  },
  {
    id: 'iw', name: 'Information Worker', abbrev: 'IW', color: '#10b981',
    cadence: 45, userCount: 1,
    composition: { info: 25, task: 35, analyst: 30, strategy: 10 }
  },
  {
    id: 'mgr', name: 'Manager', abbrev: 'MGR', color: '#f59e0b',
    cadence: 35, userCount: 1,
    composition: { info: 10, task: 20, analyst: 40, strategy: 30 }
  },
  {
    id: 'exec', name: 'Executive', abbrev: 'EXEC', color: '#8b5cf6',
    cadence: 25, userCount: 1,
    composition: { info: 5, task: 10, analyst: 30, strategy: 55 }
  },
];

let state = loadState();
let agentAccordionOpen = false;
const collapsedGroups = new Set([0, 1, 2, 3]);

function defaultState() {
  return {
    pupm: 30,
    agents: JSON.parse(JSON.stringify(DEFAULT_AGENTS)),
    groups: JSON.parse(JSON.stringify(DEFAULT_GROUPS)),
  };
}

function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (raw) {
      const s = JSON.parse(raw);
      // Validate structure
      if (s.agents && s.groups && typeof s.pupm === 'number') return s;
    }
  } catch (e) {}
  return defaultState();
}

function saveState() {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CALCULATIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function agentCostPerSession(agent) {
  return agent.turns * agent.costPerTurn;
}

function groupCostPerUser(group) {
  let cost = 0;
  state.agents.forEach(a => {
    const pct = (group.composition[a.id] || 0) / 100;
    cost += pct * a.turns * a.costPerTurn;
  });
  return group.cadence * cost;
}

// Cost per user at a given session count (for chart)
function groupCostAtSessions(group, sessions) {
  let costPerSession = 0;
  state.agents.forEach(a => {
    const pct = (group.composition[a.id] || 0) / 100;
    costPerSession += pct * a.turns * a.costPerTurn;
  });
  return sessions * costPerSession;
}

function groupBreakEvenSessions(group) {
  let costPerSession = 0;
  state.agents.forEach(a => {
    const pct = (group.composition[a.id] || 0) / 100;
    costPerSession += pct * a.turns * a.costPerTurn;
  });
  if (costPerSession <= 0) return Infinity;
  return state.pupm / costPerSession;
}

function fmt(n) { return '$' + n.toFixed(2); }
function fmtInt(n) { return '$' + Math.round(n).toLocaleString(); }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER â€” AGENT CARDS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderAgents() {
  const grid = document.getElementById('agentGrid');

  // Fast-update path: refresh values without rebuilding DOM
  if (grid.children.length === state.agents.length && grid.children.length > 0) {
    state.agents.forEach((agent, idx) => {
      const cps = agentCostPerSession(agent);
      const card = grid.children[idx];
      const valSpans = card.querySelectorAll('.slider-val');
      const inputs = card.querySelectorAll('input[type="range"]');
      inputs[0].value = agent.turns;
      valSpans[0].textContent = agent.turns;
      inputs[1].value = agent.costPerTurn;
      valSpans[1].textContent = fmt(agent.costPerTurn);
      card.querySelector('.agent-cost-per-session strong').textContent = fmt(cps);
    });
    return;
  }

  // Initial build
  grid.innerHTML = '';
  state.agents.forEach((agent, idx) => {
    const cps = agentCostPerSession(agent);
    const card = document.createElement('div');
    card.className = 'card agent-card';
    card.style.borderLeftColor = agent.color;
    card.innerHTML = `
      <div class="card-body">
        <div class="agent-name" style="color:${agent.color}">${agent.name}</div>
        <div class="slider-row">
          <label>Turns / session</label>
          <input type="range" min="1" max="20" step="1" value="${agent.turns}"
                 data-agent="${idx}" data-field="turns">
          <span class="slider-val">${agent.turns}</span>
        </div>
        <div class="slider-row">
          <label>Cost / turn</label>
          <input type="range" min="0.01" max="0.50" step="0.01" value="${agent.costPerTurn}"
                 data-agent="${idx}" data-field="costPerTurn">
          <span class="slider-val">${fmt(agent.costPerTurn)}</span>
        </div>
        <div class="agent-cost-per-session">
          Cost per session: <strong>${fmt(cps)}</strong>
        </div>
      </div>
    `;
    grid.appendChild(card);
  });

  // Bind sliders (only on initial build)
  grid.querySelectorAll('input[type="range"]').forEach(inp => {
    inp.addEventListener('input', e => {
      const ai = +e.target.dataset.agent;
      const field = e.target.dataset.field;
      const val = parseFloat(e.target.value);
      state.agents[ai][field] = val;
      saveState();
      update();
    });
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER â€” AGENT SUMMARY BAR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderAgentSummary() {
  const bar = document.getElementById('agentSummaryBar');
  if (agentAccordionOpen) {
    bar.style.display = 'none';
    return;
  }
  bar.style.display = 'flex';
  bar.innerHTML = state.agents.map(a => {
    const cps = agentCostPerSession(a);
    return `<div class="agent-summary-chip">
      <span class="dot" style="background:${a.color}"></span>
      <span>${a.name}</span>
      <span class="chip-cost">${fmt(cps)}/session</span>
    </div>`;
  }).join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER â€” USER GROUP CARDS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderGroups() {
  const grid = document.getElementById('userGrid');

  // Fast-update path: refresh values without rebuilding DOM
  if (grid.children.length === state.groups.length && grid.children.length > 0) {
    state.groups.forEach((group, gi) => {
      const cost = groupCostPerUser(group);
      const diff = cost - state.pupm;
      const badgeClass = Math.abs(diff) < 0.5 ? 'even' : diff < 0 ? 'under' : 'over';
      const badgeText  = Math.abs(diff) < 0.5 ? 'At break-even' : diff < 0
          ? `${fmt(Math.abs(diff))} under PUPM` : `${fmt(diff)} over PUPM`;
      const badgeIcon  = Math.abs(diff) < 0.5 ? 'âš–ï¸' : diff < 0 ? 'âœ…' : 'âš ï¸';
      const beSessions = groupBreakEvenSessions(group);
      const card = grid.children[gi];

      // Update cost display
      const costEl = card.querySelector('.monthly-cost');
      costEl.style.color = badgeClass === 'over' ? 'var(--red)' : badgeClass === 'under' ? 'var(--green)' : 'var(--orange)';
      costEl.innerHTML = `${fmt(cost)} <span style="font-size:.7rem;font-weight:400;color:var(--text-muted)">/ user / mo</span>`;

      // Update badge
      const badgeEl = card.querySelector('.cost-badge');
      badgeEl.className = `cost-badge ${badgeClass}`;
      badgeEl.innerHTML = `${badgeIcon} ${badgeText}`;

      // Update cadence slider
      const fieldInputs = card.querySelectorAll('input[data-field]');
      fieldInputs[0].value = group.cadence;
      fieldInputs[0].nextElementSibling.textContent = group.cadence;

      // Update composition sliders
      card.querySelectorAll('input[data-comp]').forEach(inp => {
        const aid = inp.dataset.comp;
        inp.value = group.composition[aid];
        inp.nextElementSibling.textContent = group.composition[aid] + '%';
      });

      // Update comp bar & break-even
      renderCompBar(gi);
      card.querySelector('.be-text').innerHTML =
        `Break-even: <strong>${beSessions === Infinity ? 'âˆ' : Math.round(beSessions)} sessions/mo</strong>`;
    });
    return;
  }

  // Initial build
  grid.innerHTML = '';
  state.groups.forEach((group, gi) => {
    const cost = groupCostPerUser(group);
    const diff = cost - state.pupm;
    const badgeClass = Math.abs(diff) < 0.5 ? 'even' : diff < 0 ? 'under' : 'over';
    const badgeText  = Math.abs(diff) < 0.5 ? 'At break-even' : diff < 0
        ? `${fmt(Math.abs(diff))} under PUPM` : `${fmt(diff)} over PUPM`;
    const badgeIcon  = Math.abs(diff) < 0.5 ? 'âš–ï¸' : diff < 0 ? 'âœ…' : 'âš ï¸';
    const beSessions = groupBreakEvenSessions(group);
    const isCollapsed = collapsedGroups.has(gi);

    const card = document.createElement('div');
    card.className = 'card user-card';
    card.innerHTML = `
      <div class="card-accent" style="background:${group.color};"></div>
      <div class="user-header user-toggle" data-group="${gi}">
        <div class="group-name"><span class="dot" style="background:${group.color}"></span>${group.name} (${group.abbrev})</div>
        <div style="display:flex;align-items:center;gap:.6rem;">
          <div>
            <div class="monthly-cost" style="color:${badgeClass === 'over' ? 'var(--red)' : badgeClass === 'under' ? 'var(--green)' : 'var(--orange)'}">
              ${fmt(cost)} <span style="font-size:.7rem;font-weight:400;color:var(--text-muted)">/ user / mo</span>
            </div>
            <div style="text-align:right;margin-top:2px;">
              <span class="cost-badge ${badgeClass}">${badgeIcon} ${badgeText}</span>
            </div>
          </div>
          <span class="toggle-chevron${isCollapsed ? ' collapsed' : ''}" title="Expand to edit">â–¾</span>
        </div>
      </div>
      <div class="card-body${isCollapsed ? ' collapsed' : ''}">
        <div class="slider-row">
          <label>Sessions / mo</label>
          <input type="range" min="1" max="100" step="1" value="${group.cadence}"
                 data-group="${gi}" data-field="cadence">
          <span class="slider-val">${group.cadence}</span>
        </div>
        <div class="comp-label">Agent Composition</div>
        <div class="comp-bar" id="compBar-${gi}"></div>
        ${state.agents.map(a => `
          <div class="slider-row">
            <label style="color:${a.color}">${a.name.split(' ').slice(0,2).join(' ')}</label>
            <input type="range" min="0" max="100" step="1" value="${group.composition[a.id]}"
                   data-group="${gi}" data-comp="${a.id}">
            <span class="slider-val">${group.composition[a.id]}%</span>
          </div>
        `).join('')}
        <div class="be-text" style="font-size:.72rem;color:var(--text-muted);text-align:right;margin-top:.3rem;">
          Break-even: <strong>${beSessions === Infinity ? 'âˆ' : Math.round(beSessions)} sessions/mo</strong>
        </div>
      </div>
    `;
    grid.appendChild(card);
    renderCompBar(gi);
  });

  // Bind user-toggle clicks (accordion per group)
  grid.querySelectorAll('.user-toggle').forEach(header => {
    header.addEventListener('click', e => {
      if (e.target.closest('input')) return;
      const gi = +header.dataset.group;
      const card = header.closest('.user-card');
      const body = card.querySelector('.card-body');
      const chevron = header.querySelector('.toggle-chevron');
      if (collapsedGroups.has(gi)) {
        collapsedGroups.delete(gi);
        body.classList.remove('collapsed');
        chevron.classList.remove('collapsed');
      } else {
        collapsedGroups.add(gi);
        body.classList.add('collapsed');
        chevron.classList.add('collapsed');
      }
    });
  });

  // Bind group sliders (only on initial build)
  grid.querySelectorAll('input[data-field]').forEach(inp => {
    inp.addEventListener('input', e => {
      const gi = +e.target.dataset.group;
      const field = e.target.dataset.field;
      state.groups[gi][field] = parseFloat(e.target.value);
      saveState();
      update();
    });
  });

  // Bind composition sliders with auto-normalization (only on initial build)
  grid.querySelectorAll('input[data-comp]').forEach(inp => {
    inp.addEventListener('input', e => {
      const gi = +e.target.dataset.group;
      const compId = e.target.dataset.comp;
      const newVal = parseInt(e.target.value);
      normalizeComposition(gi, compId, newVal);
      saveState();
      update();
    });
  });
}

function normalizeComposition(gi, changedId, newVal) {
  const group = state.groups[gi];
  const otherIds = state.agents.map(a => a.id).filter(id => id !== changedId);
  const oldOtherSum = otherIds.reduce((s, id) => s + group.composition[id], 0);
  const remaining = 100 - newVal;

  group.composition[changedId] = newVal;

  if (oldOtherSum === 0) {
    // Distribute evenly among others
    const each = Math.floor(remaining / otherIds.length);
    let leftover = remaining - each * otherIds.length;
    otherIds.forEach((id, i) => {
      group.composition[id] = each + (i < leftover ? 1 : 0);
    });
  } else {
    // Proportional redistribution
    let assigned = 0;
    otherIds.forEach((id, i) => {
      if (i === otherIds.length - 1) {
        group.composition[id] = Math.max(0, remaining - assigned);
      } else {
        const share = Math.round((group.composition[id] / oldOtherSum) * remaining);
        group.composition[id] = Math.max(0, share);
        assigned += group.composition[id];
      }
    });
  }
}

function renderCompBar(gi) {
  const bar = document.getElementById(`compBar-${gi}`);
  if (!bar) return;
  const group = state.groups[gi];
  bar.innerHTML = state.agents.map(a =>
    `<div style="width:${group.composition[a.id]}%;background:${a.color};"></div>`
  ).join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER â€” BREAK-EVEN CHART
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let chartInstance = null;

function renderChart() {
  const ctx = document.getElementById('breakEvenChart').getContext('2d');

  // Determine x-axis range: ensure all break-even points visible
  const breakEvens = state.groups.map(g => groupBreakEvenSessions(g)).filter(b => b !== Infinity);
  const maxBE = breakEvens.length > 0 ? Math.max(...breakEvens) : 0;
  const maxCadence = Math.max(...state.groups.map(g => g.cadence), 10);
  const rawMax = Math.max(maxBE * 1.4, maxCadence * 2, 30);
  const xMax = Math.ceil(rawMax / 5) * 5;
  const step = Math.max(1, Math.round(xMax / 50));
  const xLabels = [];
  for (let i = 0; i <= xMax; i += step) xLabels.push(i);

  const datasets = state.groups.map(group => {
    // Mark the current cadence point on the line
    const pointRadii = xLabels.map(s => {
      // Show dot at current cadence position (nearest label)
      if (Math.abs(s - group.cadence) <= step / 2) return 5;
      return 0;
    });
    const be = groupBreakEvenSessions(group);
    const beText = be === Infinity ? 'âˆ' : Math.round(be);
    return {
      label: `${group.abbrev}: ${beText}`,
      _fullLabel: `${group.name} (${group.abbrev}) Break-Even: ${beText} sessions/mo`,
      data: xLabels.map(s => groupCostAtSessions(group, s)),
      borderColor: group.color,
      backgroundColor: group.color + '18',
      borderWidth: 2.5,
      pointRadius: pointRadii,
      pointBackgroundColor: group.color,
      pointBorderColor: '#fff',
      pointBorderWidth: 2,
      pointHoverRadius: 5,
      tension: 0.1,
      fill: false,
    };
  });

  // Chart annotations (PUPM line only â€” break-even is shown in the legend)
  const annotations = {};

  // PUPM line annotation â€” label at end so it doesn't obscure crossover zone
  annotations['pupmLine'] = {
    type: 'line',
    yMin: state.pupm,
    yMax: state.pupm,
    borderColor: '#ef4444',
    borderWidth: 2,
    borderDash: [8, 4],
    label: {
      display: true,
      content: `PUPM: ${fmt(state.pupm)}`,
      position: 'end',
      backgroundColor: 'rgba(239,68,68,.85)',
      color: '#fff',
      font: { size: 10, weight: 'bold' },
      padding: { top: 2, bottom: 2, left: 6, right: 6 },
      borderRadius: 4,
    }
  };

  const config = {
    type: 'line',
    data: { labels: xLabels, datasets },
    options: {
      responsive: true,
      maintainAspectRatio: true,
      aspectRatio: 1.5,
      interaction: { mode: 'index', intersect: false },
      scales: {
        x: {
          title: { display: true, text: 'Sessions per Month', font: { weight: 'bold', size: 13 } },
          grid: { color: '#f1f5f9' },
        },
        y: {
          title: { display: true, text: 'Monthly Cost per User ($)', font: { weight: 'bold', size: 13 } },
          grid: { color: '#f1f5f9' },
          ticks: { callback: v => '$' + v },
          beginAtZero: true,
        }
      },
      plugins: {
        legend: {
          display: false,
        },
        annotation: { annotations },
        tooltip: {
          backgroundColor: '#1e293b',
          titleFont: { size: 13 },
          bodyFont: { size: 12 },
          padding: 10,
          cornerRadius: 8,
          callbacks: {
            label: ctx => `${ctx.dataset._fullLabel || ctx.dataset.label}: ${fmt(ctx.parsed.y)}`,
            afterBody: items => {
              if (items.length > 0) return `PUPM: ${fmt(state.pupm)}`;
            }
          }
        }
      }
    },
    plugins: [{ /* annotation plugin registered globally */ }]
  };

  if (chartInstance) {
    chartInstance.data = config.data;
    chartInstance.options = config.options;
    chartInstance.update('none');
  } else {
    chartInstance = new Chart(ctx, config);
  }

  // Build custom HTML legend with tooltips
  const legendEl = document.getElementById('chartLegend');
  legendEl.innerHTML = datasets.map(ds =>
    `<span class="chart-legend-item" title="${ds._fullLabel || ds.label}">
      <span class="legend-dot" style="background:${ds.borderColor}"></span>
      <span class="legend-be">${ds.label}</span>
    </span>`
  ).join('');
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER â€” ORG SUMMARY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderSummary() {
  let totalUsers = 0, totalConsumption = 0, totalLicense = 0;

  const rows = state.groups.map(group => {
    const perUser = groupCostPerUser(group);
    const consumptionTotal = perUser * group.userCount;
    const licenseTotal = state.pupm * group.userCount;
    totalUsers += group.userCount;
    totalConsumption += consumptionTotal;
    totalLicense += licenseTotal;
    return { group, perUser, consumptionTotal, licenseTotal };
  });

  const delta = totalLicense - totalConsumption;
  const pctSavings = totalLicense > 0 ? (delta / totalLicense * 100) : 0;

  // Stats
  const statsEl = document.getElementById('summaryStats');
  statsEl.innerHTML = `
    <div class="summary-stat">
      <div class="stat-label">Total Users</div>
      <div class="stat-value">${totalUsers.toLocaleString()}</div>
    </div>
    <div class="summary-stat">
      <div class="stat-label">Consumption Cost</div>
      <div class="stat-value" style="color:var(--accent)">${fmtInt(totalConsumption)}</div>
      <div class="stat-sub">/ month</div>
    </div>
    <div class="summary-stat">
      <div class="stat-label">License Cost (PUPM)</div>
      <div class="stat-value" style="color:#ef4444">${fmtInt(totalLicense)}</div>
      <div class="stat-sub">/ month</div>
    </div>
    <div class="summary-stat">
      <div class="stat-label">${delta >= 0 ? 'Savings with Consumption' : 'Extra Cost vs License'}</div>
      <div class="stat-value" style="color:${delta >= 0 ? 'var(--green)' : 'var(--red)'}">
        ${fmtInt(Math.abs(delta))}
      </div>
      <div class="stat-sub">${Math.abs(pctSavings).toFixed(1)}% ${delta >= 0 ? 'savings' : 'premium'}</div>
    </div>
  `;

  // Table
  const table = document.getElementById('summaryTable');
  table.querySelector('thead').innerHTML = `
    <tr>
      <th>User Group</th>
      <th>Users</th>
      <th>Cost / User</th>
      <th>Consumption Total</th>
      <th>License Total</th>
      <th>Î” Delta</th>
    </tr>
  `;
  table.querySelector('tbody').innerHTML = rows.map((r, ri) => {
    const d = r.licenseTotal - r.consumptionTotal;
    return `
      <tr>
        <td><span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${r.group.color};margin-right:6px;"></span>${r.group.name}</td>
        <td>
          <input type="text" inputmode="numeric" maxlength="7" value="${r.group.userCount.toLocaleString()}"
                 data-sumgroup="${ri}" class="user-count-input">
        </td>
        <td>${fmt(r.perUser)}</td>
        <td>${fmtInt(r.consumptionTotal)}</td>
        <td>${fmtInt(r.licenseTotal)}</td>
        <td style="color:${d >= 0 ? 'var(--green)' : 'var(--red)'}; font-weight:600;">
          ${d >= 0 ? '+' : ''}${fmtInt(d)}
        </td>
      </tr>
    `;
  }).join('') + `
    <tr class="total-row">
      <td>Total</td>
      <td>${totalUsers.toLocaleString()}</td>
      <td>â€”</td>
      <td>${fmtInt(totalConsumption)}</td>
      <td>${fmtInt(totalLicense)}</td>
      <td style="color:${delta >= 0 ? 'var(--green)' : 'var(--red)'}; font-weight:700;">
        ${delta >= 0 ? '+' : ''}${fmtInt(delta)}
      </td>
    </tr>
  `;

  // Recommendation
  const recEl = document.getElementById('recommendation');
  if (delta >= 0) {
    recEl.className = 'recommendation consumption-wins';
    recEl.innerHTML = `
      <span class="rec-icon">ğŸ’¡</span>
      <div>
        <div>Consumption model saves your organization</div>
        <div class="rec-savings">${fmtInt(Math.abs(delta))} / month (${Math.abs(pctSavings).toFixed(1)}% savings)</div>
        <div class="rec-annual">
          <span class="annual-label">Annual<br>Savings</span>
          <span>${fmtInt(Math.abs(delta) * 12)}</span>
        </div>
      </div>
    `;
  } else {
    recEl.className = 'recommendation license-wins';
    recEl.innerHTML = `
      <span class="rec-icon">ğŸ”‘</span>
      <div>
        <div>Per-user license saves your organization</div>
        <div class="rec-savings">${fmtInt(Math.abs(delta))} / month (${Math.abs(pctSavings).toFixed(1)}% savings)</div>
        <div class="rec-annual">
          <span class="annual-label">Annual<br>Savings</span>
          <span>${fmtInt(Math.abs(delta) * 12)}</span>
        </div>
      </div>
    `;
  }

  // Bind user-count inputs in summary table
  table.querySelectorAll('.user-count-input').forEach(inp => {
    inp.addEventListener('input', e => {
      // Strip non-digits, cap at 7 digits, update state silently (no DOM rebuild)
      const raw = e.target.value.replace(/[^0-9]/g, '').slice(0, 7);
      e.target.value = raw;
      const val = parseInt(raw) || 0;
      const gi = +e.target.dataset.sumgroup;
      state.groups[gi].userCount = Math.max(val, 0);
      saveState();
    });
    inp.addEventListener('blur', e => {
      const gi = +e.target.dataset.sumgroup;
      if (state.groups[gi].userCount < 1) state.groups[gi].userCount = 1;
      saveState();
      update();
    });
    inp.addEventListener('keydown', e => {
      if (e.key === 'Enter') { e.target.blur(); }
      if (e.key === 'Tab') {
        e.preventDefault();
        const gi = +e.target.dataset.sumgroup;
        const nextGi = e.shiftKey ? gi - 1 : gi + 1;
        if (state.groups[gi].userCount < 1) state.groups[gi].userCount = 1;
        saveState();
        update();
        const nextInput = document.querySelector(`.user-count-input[data-sumgroup="${nextGi}"]`);
        if (nextInput) { nextInput.focus(); nextInput.select(); }
      }
    });
    inp.addEventListener('focus', e => {
      e.target.select();
    });
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MAIN UPDATE & INIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function update() {
  renderAgents();
  renderAgentSummary();
  renderGroups();
  renderChart();
  renderSummary();
}

function forceFullRebuild() {
  document.getElementById('agentGrid').innerHTML = '';
  document.getElementById('userGrid').innerHTML = '';
  collapsedGroups.clear();
}

function resetDefaults() {
  state = defaultState();
  saveState();
  agentAccordionOpen = false;
  forceFullRebuild();
  // Restore default collapsed states for all groups
  for (let i = 0; i < state.groups.length; i++) collapsedGroups.add(i);
  document.getElementById('agentBody').style.display = 'none';
  document.getElementById('agentChevron').classList.add('collapsed');
  document.getElementById('pupmSlider').value = state.pupm;
  document.getElementById('pupmValue').textContent = fmt(state.pupm);
  if (chartInstance) { chartInstance.destroy(); chartInstance = null; }
  update();
}

// Agent accordion toggle
document.getElementById('agentToggle').addEventListener('click', () => {
  agentAccordionOpen = !agentAccordionOpen;
  const body = document.getElementById('agentBody');
  const chevron = document.getElementById('agentChevron');
  if (agentAccordionOpen) {
    body.style.display = '';
    chevron.classList.remove('collapsed');
  } else {
    body.style.display = 'none';
    chevron.classList.add('collapsed');
  }
  renderAgentSummary();
});

// PUPM slider
document.getElementById('pupmSlider').value = state.pupm;
document.getElementById('pupmValue').textContent = fmt(state.pupm);
document.getElementById('pupmSlider').addEventListener('input', e => {
  state.pupm = parseFloat(e.target.value);
  document.getElementById('pupmValue').textContent = fmt(state.pupm);
  saveState();
  update();
});

// Reset button
document.getElementById('resetBtn').addEventListener('click', resetDefaults);

// Initial render
update();
</script>
</body>
</html>
